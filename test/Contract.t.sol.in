// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Contract.sol";

address constant addr = 0x000000000000000000000000000000000000000b;
address constant sysaddr = 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE;
uint256 constant rootmod = 98304;
bytes32 constant root    = hex"88e96d4537bea4d9c05d12549907b32561d3bf31f45aae734cdc119f13406cb6";

function timestamp() view returns (bytes32) {
        return bytes32(uint256(block.timestamp));
}

function timestamp_idx() view returns (bytes32) {
        return bytes32(uint256(block.timestamp % rootmod));
}

function root_idx() view returns (bytes32) {
        return bytes32(uint256(block.timestamp % rootmod + rootmod));
}

contract ContractTest is Test {
    address unit;

    function setUp() public {
        vm.etch(addr, hex"@bytecode@");
        unit = addr;
    }

    function testRead() public {
        vm.store(unit, timestamp_idx(), timestamp());
        vm.store(unit, root_idx(), root);

        (bool ret, bytes memory data) = unit.call(bytes.concat(bytes4(0x9507d39a), bytes32(uint256(block.timestamp))));

        assertTrue(ret);
        assertEq(data, bytes.concat(root));
    }

    function testReadWrongSig() public {
        assertTrue(unit != address(0));

        vm.store(unit, timestamp_idx(), timestamp());
        vm.store(unit, root_idx(), root);

        (bool ret, /*bytes memory data*/) = unit.call(bytes.concat(bytes4(0x01020304), bytes32(uint256(block.timestamp))));
        
        assertFalse(ret);
    }

    function testUpdate() public {
        vm.prank(sysaddr);
        (bool ret, bytes memory data) = unit.call(bytes.concat(root));

        assertTrue(ret);
        assertEq(data, hex"");

        bytes32 got = vm.load(unit, timestamp_idx());
        assertEq(got, timestamp());

        got = vm.load(unit, root_idx());
        assertEq(got, root);
    }
}
